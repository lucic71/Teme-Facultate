Popescu Lucian Ioan 321CD

I. Task1 and bruteforce_singlebyte_xor
--------------------------------------

For this task I used dynamic memory allocation using calloc because I decided
that using the stack for string manipulation operations would be too unpleasant.
The idea of my implementation is straightforward. Use one loop to try each key
in the range 0-255, use one more loop to iterate through each column of the
matrix and one final loop to iterate through each line of the matrix, even if
the image was represented as an array, I needed to get the message line number
at the end of the subroutine.
After each line is traversed, the dynamic allocated block, that contains now the
line with the xor operation applied on it, is checked to see it contains the
string 'revient' using a strstr version implemented by me. If it does, the
subroutine puts the key and the line in <EAX> and stores the message in the
calloc'd block.
The strstr implementation works as following: iterate through each byte from
haystack, check if it's equal with the first byte in needle, if so iterate
through each byte from haystack and needle in parallel and check if they are
equal, if not continue.
In the end the message is printed using printf in solve_task1 and the control
is passed to the main program.

II. Task2
---------

I solved this task directly in solve_task2 label. For this I needed to call
the function defined in the previous task, namely bruteforce_singlebyte_xor in
order to get the key and the line. After that I decrypted the whole matrix and
inserted my message on the next line. In the end I encrypted the message using
the new generated key.

III. Task3, morse_encrypt and morse binary tree
-----------------------------------------------

The main idea here is that I managed to avoid a hardcoded solution, where I
would have written the morse encoding for each symbol in the alphabet. Thus
I created a binary tree which contains each symbol based on its encoding. The
tree works much like a Huffman tree. When traversed, it adds a '-' to the
symbol encoding if we go from the root to the right and it adds a '.' to the
symbol encoding if we go from the root to the left.
The algorithm for writing the morse code in our case works as follows:
    -load a symbol from the source string
    -if the symbol is comma then write the corresponding encoding
    -if the symbol is not comma then do the following:
        -find the position of the symbol in the binary tree
        -make repeated divisions by 2 until the number is equal to 1
        -if the remained is equal to 1 then push a dash on the stack else
            push dot
        -finally, pop each dash and dot and write them in the image
    -write a whitespace symbol(0x20) after each letter in the alphabet
The binary tree and its length are found in .rodata section.

IV. Task4 and lsb_encode
------------------------

The implementation for lsb_encode is pretty short. It loads bytes from the msg
string and shifts left each bit into carry flag. If the carry is set, the
MSB was set and we set the LSB at the corresponding position in the image. If
the carry flag is not set, the MSB was not set and we reset the LSB at the
corresponding position in the image. I tried to find a better approach to this
solution, that would remove the three labels: ShiftBitToCarry, SetLSBOne and
SetLSBZero with only one label but I couldn't find it. The idea would sound
as following: (if CF == 1) then set LSB else reset LSB. The setCC instructions
in x86 operate only on bytes, not on bits.

V. Task5 and lsb_decode
-----------------------

Because I knew that the seeked string will contain maximum 20 bytes, I allocated
a 21 bytes string that will contain our decoded message at the end of the
subroutine. After that I took each group of 8 byts and substracted their LSB,
put it at the corresponding position in the new generated byte and stored the
byte in the allocated string. In the end I printed the message with printf and
free'd the memory.

VI. Task6 and blur
------------------

Nothing special happens in solve_task6 label, as with the previous task. It
only calls the blur subroutine which worsk in the following way. Allocate space
for a new matrix. Copy the first and last lines and columns and for the inner
lines and columns apply the arithmetic mean between the upper, lower, right,
left and current element. I found very useful the lodsd and stosd instructions
because they did not only stored and loaded bytes from <ESI> and <EDI> but also
incremented correctly the streams of bytes.

VII. Additional notes
---------------------
I also created a convenience subroutine for printing a matrix that takes as
arguments the matrix to be printed, assuming that the height and width are
the same as the matrix received as command line argument.
For this homework I used some bytes stored in .rodata segment because they
were better suited to be declared there. The first two constants are used
through the whole homework, NULL being used when comparing with 0 and with
nullptr(see return value of strstr). MAX_KEY is used in task1 to define the
upper limit of the key used for bruteforce. PrintStringFormat and
PrintIntegerFormat are used when printing with printf in task1 or task5 for
example. MessageToSend is used in task2 and MorseCodeBinaryTree is used in
task3, they both are read only intended.

VIII. Feedback
--------------
Great homework!!! I enjoyed this introduction in steganography and I hope the
next homeworks will be as interesting as this one.
